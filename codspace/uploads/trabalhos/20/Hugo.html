<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Survivor: One-Player Arena</title>
<style>
  :root{
    --bg:#0b0f13;
    --panel:#0f1720;
    --accent:#ffd166;
    --danger:#ff4d4d;
    --muted:#9aa7b2;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Press Start 2P",monospace;color:#e9f3f7}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:14px}
  canvas{border-radius:12px;image-rendering:optimizeSpeed; background:linear-gradient(180deg,#071018,#071823); box-shadow: 0 8px 30px rgba(0,0,0,0.6)}
  #ui {width:900px; max-width:95%; margin-top:12px; display:flex;gap:14px;align-items:center;justify-content:space-between}
  .panel{background:linear-gradient(180deg,var(--panel),#081018); padding:10px 14px;border-radius:8px; box-shadow: inset 0 -6px 12px rgba(0,0,0,0.4)}
  .hud {display:flex;gap:12px;align-items:center}
  .bar {width:180px;height:14px;background:#092027;border-radius:6px;overflow:hidden;box-shadow:inset 0 -2px 6px rgba(0,0,0,0.6)}
  .bar > .fill{height:100%;background:linear-gradient(90deg,var(--accent),#ffb86b);width:100%}
  .small{font-size:12px;color:var(--muted)}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0ea5a4;color:#001;cursor:pointer}
  button.secondary{background:#1f2937;color:#e6eef3}
  .center{text-align:center}
  @media (max-width:640px){canvas{width:100%;height:auto}}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="900" height="600"></canvas>

  <div id="ui">
    <div class="panel hud">
      <div>
        <div style="font-weight:700">Survivor Arena</div>
        <div class="small">Sobreviva o máximo; mira com o mouse — clique para atirar</div>
      </div>
      <div style="width:18px"></div>
      <div>
        <div class="small">Vida</div>
        <div class="bar"><div id="hpFill" class="fill" style="width:100%"></div></div>
      </div>
      <div style="width:8px"></div>
      <div>
        <div class="small">Escudo</div>
        <div class="bar"><div id="shieldFill" class="fill" style="width:0%;background:linear-gradient(90deg,#6ee7ff,#60a5fa)"></div></div>
      </div>
    </div>

    <div class="panel center" style="width:380px">
      <div id="centerText" style="font-weight:700;font-size:16px">Wave 1 — Sobreviva!</div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:6px">
        <div class="small">Tempo: <span id="time">0.0</span>s</div>
        <div class="small">Kills: <span id="kills">0</span></div>
        <div class="small">Power: <span id="power">Normal</span></div>
      </div>
    </div>

    <div class="panel" style="display:flex;gap:8px;align-items:center">
      <button id="btnRestart">Reiniciar</button>
      <button id="btnPause" class="secondary">Pausar</button>
      <div style="width:8px"></div>
      <div class="small">Controles: WASD mover • Mouse mirar • Clique atirar • E escudo</div>
    </div>
  </div>
</div>

<script>
/*
  Survivor Arena - Single Player
  - Top-down shooter survival
  - WASD move, mouse aim, click to shoot, E to use shield
  - Enemies spawn in waves, pickups appear randomly
  - Simple WebAudio feedback (beeps)
*/

/* -------------------------
   Setup & Utilities
   ------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

function rand(min,max){return Math.random()*(max-min)+min}
function randint(min,max){return Math.floor(rand(min,max+1))}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}

/* WebAudio lightweight SFX */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audio = new (AudioCtx || function(){return null})();

function beep(freq=440, time=0.08, type='sine', gain=0.08){
  if(!audio) return;
  const o = audio.createOscillator();
  const g = audio.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(audio.destination);
  o.start();
  o.stop(audio.currentTime + time);
}

/* -------------------------
   Input
   ------------------------- */
const keys = {};
let mouse = {x:W/2,y:H/2,down:false};
window.addEventListener('keydown',e=>keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()] = false);
canvas.addEventListener('mousemove',e=>{
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  mouse.x = (e.clientX - rect.left) * scaleX;
  mouse.y = (e.clientY - rect.top) * scaleY;
});
canvas.addEventListener('mousedown',e=>{ mouse.down = true; if(audio&&audio.state==='suspended') audio.resume(); });
canvas.addEventListener('mouseup',e=>mouse.down = false);

/* -------------------------
   Game Objects
   ------------------------- */

class Player {
  constructor(){
    this.x = W/2; this.y = H/2; this.r = 18;
    this.speed = 3.4;
    this.color = '#ffd166';
    this.hp = 100;
    this.maxHp = 100;
    this.shield = 0; // timer
    this.shieldCooldown = 0;
    this.bullets = [];
    this.reload = 0;
    this.weapon = {rate:8, dmg:14, spread:0.04};
    this.kills = 0;
    this.powerState = 'Normal';
    this.score = 0;
    this.flash = 0;
  }

  update(){
    // movement WASD
    let vx = 0, vy = 0;
    if(keys['w']) vy = -1;
    if(keys['s']) vy = 1;
    if(keys['a']) vx = -1;
    if(keys['d']) vx = 1;
    if(vx!==0||vy!==0){
      const len = Math.hypot(vx,vy);
      vx = vx/len * this.speed;
      vy = vy/len * this.speed;
    }
    this.x += vx;
    this.y += vy;
    this.x = clamp(this.x, this.r, W - this.r);
    this.y = clamp(this.y, this.r, H - this.r);

    // shield
    if(keys['e'] && this.shieldCooldown<=0 && this.shield<=0){
      this.shield = 180; // 3s
      this.shieldCooldown = 900; // 15s
      beep(880,0.06,'sine',0.06);
    }
    if(this.shield>0) this.shield--;
    if(this.shieldCooldown>0 && this.shield<=0) this.shieldCooldown--;

    // shooting
    if(mouse.down && this.reload<=0){
      this.fire();
      this.reload = this.weapon.rate;
    }
    if(this.reload>0) this.reload--;

    // bullets update
    this.bullets = this.bullets.filter(b=>!b.dead);
    this.bullets.forEach(b=>b.update());

    if(this.flash>0) this.flash -= 0.04;
  }

  fire(){
    // compute direction to mouse
    let dx = mouse.x - this.x, dy = mouse.y - this.y;
    const ang = Math.atan2(dy,dx);
    let spread = this.weapon.spread * (this.powerState==='Berserk' ? 0.6 : 1);
    // spawn 1 projectile; could be more for shotguns
    const a = ang + rand(-spread,spread);
    const speed = 8 + (this.powerState==='Rapid'?2:0);
    const vx = Math.cos(a)*speed, vy = Math.sin(a)*speed;
    const dmg = this.weapon.dmg * (this.powerState==='Power'?1.6:1);
    const b = new Bullet(this.x + Math.cos(a)*(this.r+6), this.y + Math.sin(a)*(this.r+6), vx, vy, dmg, '#fff7e6');
    this.bullets.push(b);
    beep(1200,0.04,'square',0.02);
  }

  takeDamage(d){
    if(this.shield>0) return;
    this.hp -= d;
    this.flash = 1;
    beep(200,0.08,'sawtooth',0.08);
    if(this.hp<0) this.hp=0;
  }

  draw(){
    // player body
    ctx.save();
    if(this.flash>0) ctx.globalAlpha = 0.6 + 0.4*this.flash;
    ctx.fillStyle = this.color;
    roundRect(ctx,this.x - this.r, this.y - this.r, this.r*2, this.r*2, this.r*0.4, true, false);
    ctx.restore();

    // eyes
    ctx.fillStyle = '#081827';
    ctx.beginPath();
    ctx.ellipse(this.x - 6, this.y - 4, 4,5,0,0,Math.PI*2);
    ctx.ellipse(this.x + 6, this.y - 4, 4,5,0,0,Math.PI*2);
    ctx.fill();

    // shield ring
    if(this.shield>0){
      ctx.strokeStyle = 'rgba(102,204,255,0.85)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r+8, 0, Math.PI*2);
      ctx.stroke();
    }

    // bullets
    this.bullets.forEach(b=>b.draw());
  }
}

class Bullet {
  constructor(x,y,vx,vy,dmg,color){
    this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.r=4;this.dmg=dmg;this.dead=false;this.color=color;
    this.life=90;
  }
  update(){
    this.x += this.vx; this.y += this.vy;
    this.life--; if(this.life<=0) this.dead=true;
    if(this.x<-20||this.x>W+20||this.y<-20||this.y>H+20) this.dead=true;
    // collision with enemies handled externally
  }
  draw(){
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill();
  }
}

class Enemy {
  constructor(type=0){
    this.type=type;
    // spawn at border
    const edge = randint(0,3);
    if(edge===0){ this.x = rand(-40,-10); this.y = rand(0,H); }
    if(edge===1){ this.x = rand(W+10,W+40); this.y = rand(0,H); }
    if(edge===2){ this.x = rand(0,W); this.y = rand(-40,-10); }
    if(edge===3){ this.x = rand(0,W); this.y = rand(H+10,H+40); }

    // types: 0 = grunt, 1 = charger, 2 = ranged
    if(type===0){ this.speed = 1.2+Math.random()*0.8; this.hp=18; this.size=14; this.color='orange'; }
    if(type===1){ this.speed = 2.0+Math.random()*0.6; this.hp=32; this.size=20; this.color='#ff884d'; }
    if(type===2){ this.speed = 0.9+Math.random()*0.6; this.hp=24; this.size=16; this.color='#ffcc66'; this.shootCooldown=60; }
    this.dead=false;
    this.hitFlash=0;
  }

  update(){
    // find player target
    const target = player;
    const dx = target.x - this.x, dy = target.y - this.y;
    const d = Math.hypot(dx,dy);
    if(d>0){
      this.x += dx/d * this.speed;
      this.y += dy/d * this.speed;
    }

    if(this.type===2){
      this.shootCooldown--;
      if(this.shootCooldown<=0){
        // fire a projectile toward player
        const ang = Math.atan2(target.y - this.y, target.x - this.x);
        const speed = 4.2;
        bulletsEnemy.push(new Bullet(this.x + Math.cos(ang)*(this.size+4), this.y + Math.sin(ang)*(this.size+4),
                                     Math.cos(ang)*speed, Math.sin(ang)*speed, 10, this.color));
        this.shootCooldown = 120;
      }
    }

    // hit flash decay
    if(this.hitFlash>0) this.hitFlash -= 0.06;
  }

  takeDamage(d){
    this.hp -= d; this.hitFlash = 1; beep(600,0.03,'sine',0.03);
    if(this.hp<=0) this.dead=true;
  }

  draw(){
    ctx.save();
    if(this.hitFlash>0) ctx.globalAlpha = 0.5 + 0.5*this.hitFlash;
    ctx.fillStyle = this.color;
    roundRect(ctx, this.x - this.size, this.y - this.size, this.size*2, this.size*2, this.size*0.3, true, false);
    ctx.restore();

    // hp bar
    ctx.fillStyle = '#222';
    ctx.fillRect(this.x - this.size, this.y - this.size - 8, this.size*2, 5);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(this.x - this.size, this.y - this.size - 8, (this.hp/40)*this.size*2, 5);
  }
}

class Pickup {
  constructor(type){
    this.type=type; this.size=12; this.dead=false;
    this.x = rand(60,W-60); this.y = rand(60,H-60);
    // types: 'heal','power','rapid','shield'
    this.color = {heal:'#5eead4', power:'#ffd166', rapid:'#a78bfa', shield:'#60a5fa'}[type]||'#fff';
    this.t=0;
  }
  update(){ this.t+=1; }
  draw(){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(Math.sin(this.t*0.06)*0.2);
    ctx.fillStyle = this.color;
    roundRect(ctx, -this.size, -this.size, this.size*2, this.size*2, 5, true, false);
    ctx.restore();
  }
}

/* -------------------------
   Misc internals & state
   ------------------------- */
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

function randint(min,max){return Math.floor(Math.random()*(max-min+1))+min}

/* -------------------------
   Game variables
   ------------------------- */
const player = new Player();
let enemies = [];
let bulletsEnemy = []; // bullets shot by enemies
let pickups = [];
let particles = [];
let wave = 1;
let spawnTimer = 0;
let pickupTimer = 0;
let timeSurvived = 0;
let paused = false;
let gameOver = false;

/* particles for impact/explosion */
function spawnParticles(x,y,color,count=12){
  for(let i=0;i<count;i++){
    particles.push({
      x,y,
      vx:rand(-2.5,2.5), vy:rand(-2.5,2.5),
      life:rand(30,80),
      color
    });
  }
}

/* -------------------------
   Spawn logic
   ------------------------- */
function spawnWave(){
  const num = Math.min(20, 4 + Math.floor(wave * 1.5));
  for(let i=0;i<num;i++){
    const t = Math.random();
    let type = 0;
    if(t>0.85) type = 2;
    else if(t>0.6) type = 1;
    else type = 0;
    enemies.push(new Enemy(type));
  }
  spawnTimer = 300 + Math.max(0, 400 - wave*10);
}

/* -------------------------
   Pickups logic
   ------------------------- */
function spawnPickup(){
  const types = ['heal','power','rapid','shield'];
  pickups.push(new Pickup(types[randint(0,types.length-1)]));
  pickupTimer = 900 + randint(-200,200);
}

/* -------------------------
   Update & Draw loops
   ------------------------- */
function update(){
  if(paused || gameOver) return;

  timeSurvived++;
  // player
  player.update();

  // enemies
  enemies.forEach(e=>e.update());
  enemies = enemies.filter(e=>!e.dead);

  // bullets enemy
  bulletsEnemy.forEach(b=>{
    b.update();
    // hit player
    if(!player.shield && !player.shield>0){
      if(Math.hypot(b.x-player.x,b.y-player.y) < b.r + player.r){
        player.takeDamage(b.dmg || 8);
        b.dead = true;
      }
    } else {
      // if shield active, bullets destroyed
      if(player.shield>0 && Math.hypot(b.x-player.x,b.y-player.y) < b.r + player.r){
        b.dead = true;
      }
    }
  });
  bulletsEnemy = bulletsEnemy.filter(b=>!b.dead);

  // bullet collisions (player bullets vs enemies)
  player.bullets.forEach(b=>{
    enemies.forEach(e=>{
      if(!e.dead && Math.hypot(b.x-e.x,b.y-e.y) < b.r + e.size){
        e.takeDamage(b.dmg);
        b.dead = true;
        spawnParticles(b.x,b.y,'#ffb4a2',8);
        if(e.dead){
          player.kills++;
          player.score += 10;
          // small chance to spawn pickup on kill
          if(Math.random() < 0.12) pickups.push(new Pickup(['heal','power','rapid','shield'][randint(0,3)]));
          beep(880,0.04,'triangle',0.03);
        }
      }
    });
  });

  // pickups update & collect
  pickups.forEach(p=>{
    p.update();
    if(Math.hypot(p.x-player.x,p.y-player.y) < p.size + player.r){
      // apply
      if(p.type==='heal'){ player.hp = Math.min(player.maxHp, player.hp + 40); beep(900,0.06,'sine',0.07); }
      if(p.type==='power'){ player.powerState='Power'; player.weapon.dmg *= 1.5; setTimeout(()=>{ if(player.powerState==='Power'){ player.weapon.dmg /= 1.5; player.powerState='Normal'; }}, 10000); beep(1400,0.06,'square',0.06); }
      if(p.type==='rapid'){ player.powerState='Rapid'; player.weapon.rate = Math.max(3, player.weapon.rate - 3); setTimeout(()=>{ if(player.powerState==='Rapid'){ player.weapon.rate += 3; player.powerState='Normal'; }}, 10000); beep(1200,0.06,'sine',0.06); }
      if(p.type==='shield'){ player.shield = 180; player.shieldCooldown = 600; beep(1000,0.08,'sawtooth',0.07); }
      p.dead = true;
    }
  });
  pickups = pickups.filter(p=>!p.dead);

  // particles
  particles.forEach(pt=>{
    pt.x += pt.vx; pt.y += pt.vy; pt.life--;
  });
  particles = particles.filter(pt=>pt.life>0);

  // spawn waves automatically
  spawnTimer--;
  if(spawnTimer<=0){
    wave++;
    spawnWave();
    beep(500,0.08,'sine',0.06);
  }

  // spawn pickups occasionally
  pickupTimer--;
  if(pickupTimer<=0){
    spawnPickup();
  }

  // check collisions enemy vs player (melee)
  enemies.forEach(e=>{
    if(Math.hypot(e.x-player.x,e.y-player.y) < e.size + player.r){
      // enemy deals damage and also is damaged
      if(player.shield<=0) player.takeDamage(6);
      e.takeDamage(999); // enemy sacrifices itself when touching (makes the game more dynamic)
    }
  });

  // update UI elements
  document.getElementById('hpFill').style.width = (player.hp/player.maxHp*100).toFixed(1)+'%';
  document.getElementById('shieldFill').style.width = (player.shield/180*100).toFixed(1)+'%';
  document.getElementById('time').innerText = (timeSurvived/60).toFixed(1);
  document.getElementById('kills').innerText = player.kills;
  document.getElementById('power').innerText = player.powerState;

  // check game over
  if(player.hp <= 0){
    gameOver = true;
    finalText = `Você sobreviveu ${(timeSurvived/60).toFixed(1)}s — Kills: ${player.kills}`;
    beep(120,0.5,'sawtooth',0.16);
  }
}

/* -------------------------
   Draw
   ------------------------- */
function draw(){
  // background grid
  ctx.clearRect(0,0,W,H);
  // subtle vignette
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#071019'); g.addColorStop(1,'#021018');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // radial background noise
  for(let i=0;i<6;i++){
    ctx.fillStyle = `rgba(20,30,40,${0.02*(i+1)})`;
    ctx.beginPath();
    ctx.ellipse(W/2, H/2, W*0.9 - i*60, H*0.9 - i*40, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // pickups
  pickups.forEach(p=>p.draw());

  // enemies
  enemies.forEach(e=>e.draw());

  // enemy bullets
  bulletsEnemy.forEach(b=>b.draw());

  // player
  player.draw();

  // particles
  particles.forEach(pt=>{
    ctx.fillStyle = pt.color;
    ctx.fillRect(pt.x,pt.y,2,2);
  });

  // HUD overlay (top center already in DOM, but draw crosshair)
  // crosshair
  ctx.strokeStyle = 'rgba(255,255,255,0.6)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(mouse.x-10,mouse.y); ctx.lineTo(mouse.x+10,mouse.y);
  ctx.moveTo(mouse.x,mouse.y-10); ctx.lineTo(mouse.x,mouse.y+10);
  ctx.stroke();

  if(paused){
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = 'white';
    ctx.font = '36px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSADO', W/2, H/2);
  }

  if(gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#ffd166';
    ctx.font = '28px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W/2, H/2 - 28);
    ctx.fillStyle = '#fff';
    ctx.font = '18px Segoe UI';
    ctx.fillText(finalText, W/2, H/2 + 6);
    ctx.fillStyle = '#9aa7b2';
    ctx.font = '14px Segoe UI';
    ctx.fillText('Pressione Reiniciar para tentar de novo', W/2, H/2 + 36);
  }
}

/* -------------------------
   Main loop
   ------------------------- */
let finalText = '';
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

/* -------------------------
   Buttons & control
   ------------------------- */
document.getElementById('btnRestart').addEventListener('click', ()=>{
  // reset
  player.hp = player.maxHp; player.x=W/2; player.y=H/2; player.bullets=[]; player.kills=0; player.score=0;
  player.powerState='Normal'; player.weapon = {rate:8, dmg:14, spread:0.04};
  enemies=[]; pickups=[]; bulletsEnemy=[]; particles=[];
  wave=1; spawnTimer=0; pickupTimer=240; timeSurvived=0; gameOver=false; paused=false; finalText='';
  spawnWave();
});
document.getElementById('btnPause').addEventListener('click', ()=>{
  paused = !paused;
  document.getElementById('btnPause').innerText = paused ? 'Retomar' : 'Pausar';
});

/* keyboard hotkeys */
window.addEventListener('keydown', e=>{
  if(e.key.toLowerCase()==='p'){ paused = !paused; document.getElementById('btnPause').innerText = paused ? 'Retomar' : 'Pausar'; }
  if(e.key.toLowerCase()==='r'){ document.getElementById('btnRestart').click(); }
});

/* -------------------------
   Start initial wave & loop
   ------------------------- */
spawnTimer = 60;
pickupTimer = 420;
spawnWave();
loop();

</script>
</body>
</html>
